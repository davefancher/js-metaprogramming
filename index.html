<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>JavaScript Metaprogramming</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/moon.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h2>JavaScript Metaprogramming</h2>
					<hr />
					<h3>
						Dave Fancher<br />
						<span style="font-size: .5em; opacity: 50%;">
							Lead Software Engineer - Vibenomics
						</span>
					</h3>
				</section>

				<!-- <section>
					<img src="" />
				</section> -->

				<section>
					<h2>About This Presentation</h2>
					<ul>
						<li class="fragment">Covers the evolution of JavaScript's metaprogramming capabilities</li>
						<li class="fragment">Node.js-centric (v14)</li>
						<li class="fragment">Current project makes extensive use of metaprogramming techniques</li>
						<li class="fragment">My background</li>
					</ul>

					<aside class="notes">
						<ul>
							<li>Programming for ~20 years</li>
							<li>
								Traditionally in MS technologies
								<ul>
									<li>Mostly .NET</li>
									<li>C#</li>
									<li>F#</li>
								</ul>
							</li>
							<li>JS for the past ~4 years</li>
							<li>Node.js</li>
						</ul>
					</aside>
				</section>

				<section>
					<h2>What is Metaprogramming?</h2>
					<ul>
						<li class="fragment">Programming about programming/Code about code</li>
						<li class="fragment">
							3 Categories
							<ul>
								<li class="fragment">Code Generation - Code writing code</li>
								<li class="fragment">Reflection - Interrogation and manipulation</li>
								<li class="fragment">Intercession - Intercepting behavior</li>
							</ul>
						</li>						
					</ul>

					<aside class="notes">
						<ul>
							<li>Most have been available in JS since its early days</li>
						</ul>
					</aside>
				</section>

				<section>
					<section>
						<h2>Code Generation</h2>
						<h4>Code writing code</h4>
					</section>					

					<section>
						<h2>eval (ugh...)</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers>
								const sayHello =
								    eval("name => `[eval] Hello, ${name}!`;");

								sayHello("Dave"); // [eval] Hello, Dave!
							</code>
						</pre>

						<aside class="notes">
							<ul>
								<li>Scoping issues</li>
								<li>executes the code it's passed with the privileges of the caller</li>
								<li>Slower than alternatives</li>
								<li>More covered in detail elsewhere...</li>
							</ul>
						</aside>
					</section>

					<section>
						<h2>eval - Scope/Access Issues</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers>
								const name = "Dave";

								const sayHello =
								    eval("() => `[eval] Hello, ${name}`");

								sayHello();	// [eval] Hello, Dave!
							</code>
						</pre>
					</section>

					<section>
						<h2>Function Constructor</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers>
								const sayHello =
								    new Function(
								        "name",
								        "return `[func] Hello, ${name}!`");

								sayHello("Dave"); // [func] Hello, Dave!
							</code>
						</pre>

						<aside class="notes">
							<ul>
								<li>Improvement over eval</li>
								<li>Functions created this way don't close around the context</li>
								<li>These are in the global scope</li>
							</ul>
						</aside>
					</section>

					<section>
						<h2>Function Constructor - Global Scope</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers>
								const sayHello =
								    new Function(
								        "return `[func] Hello, ${name}`");

								const name = "Dave";

								sayHello();  // ?
							</code>
						</pre>
					</section>

					<section>
						<h2>Function Constructor - Global Scope</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers>
								const sayHello =
								    new Function(
								        "return `[func] Hello, ${name}`");

								const name = "Dave";

								sayHello();  // ReferenceError: name is not defined
							</code>
						</pre>
					</section>

					<section>
						<h2>Function Constructor - Global Scope</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers>
								const sayHello =
								    new Function(
								        "return `[func] Hello, ${name}`");

								global.name = "Dave";

								sayHello();  // [func] Hello, Dave
							</code>
						</pre>
					</section>

					<section>
						<h2>Function Constructor - Parameters</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers>
								const sayHello =
									new Function(
										"name", "return `[func] Hello, ${name}`");

								sayHello("Dave"); // [func] Hello, Dave
							</code>
						</pre>
					</section>

					<section>
						<h2>vm Module (Node.js)</h2>
						
						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers="1-17|1|5-8|10-11,13-14|16-17|3|16-17">
								const vm = require("node:vm");

								global.scopeName = "global";

								const script =
									new vm.Script(
										"name => `[vm - ${scopeName} context] Hello, ${name}`;"
									);
								
								const sayHelloThisContext =
									script.runInThisContext();

								const sayHelloNewContext =
									script.runInNewContext({ scopeName: "new" });
								
								sayHelloThisContext("Dave"); // [vm - global context] Hello, Dave
								sayHelloNewContext("Dave");  // [vm - new context] Hello, Dave
							</code>
						</pre>

						<aside class="notes">
							<ul>
								<li>V8 Virtual Machine</li>
								<li>Allows running code in a separate global context</li>
							</ul>
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h2>Legacy Reflection/Introspection</h2>

						<h4>Interrogate and Manipulate</h4>
					</section>

					<section>
						<h2>Detecting Properties</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers>
								const myObject = {
									firstName: "Dave",
									lastName: "Fancher",
									age: 42
								};
	
								"firstName" in myObject;  // true
								"lastName" in myObject;   // true
								"middleName" in myObject; // false
							</code>
						</pre>
					</section>

					<section>
						<h2>Enumerating Properties</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers>
								const myObject = {
									firstName: "Dave",
									lastName: "Fancher",
									age: 42
								};

								const allAttrs = [];

								for (attr in myObject) {
									allAttrs.push(attr);
								}

								// [ "firstName", "lastName", "age" ]
							</code>
						</pre>
					</section>

					<section>
						<h2>Copying Values</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers>
								const myObject = {
									firstName: "Dave",
									lastName: "Fancher",
									age: 42
								};

								const newObj = {};
								for (attr in myObject) {
									newObj[attr] = myObject[attr];
								}

								/* {
									firstName: "Dave",
									lastName: "Fancher",
									age: 42
								} */
							</code>
						</pre>
					</section>

					<section>
						<h2>Removing Properties</h2>
	
						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers>
								const myObject = {
									firstName: "Dave",
									lastName: "Fancher",
									age: 42
								};
	
								delete myObject.age;        // true
								delete myObject.middleName; // true
	
								"firstName" in myObject;    // true
								"lastName" in myObject;     // true
								"age" in myObject;          // false
							</code>
						</pre>
					</section>
	
					<section>
						<h2>Determing Types...maybe</h2>
	
						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers>
								// Numbers
								typeof 37;                  // number
								typeof Number(37);          // number
								typeof new Number(37);      // object
								typeof NaN;                 // number
								typeof Number("nope");      // number
								
								// Strings
								typeof "Hello";             // string
								typeof String("Hello");     // string
								typeof new String("Hello"); // object
	
								// Booleans
								typeof true;                // boolean
								typeof Boolean(1);          // boolean
								typeof new Boolean(1);      // object
	
								// Date
								typeof new Date();          // object
								
								// Arrays
								typeof [ 1, 2, 3 ];         // object
								
								// nils
								typeof null;                // object
								typeof undefined;           // undefined
								
								// functions
								typeof (function (name) {
									return `Hello, ${name}`;
								});                         // function
								
								typeof (name => `Hello, ${name}`);  // function
							</code>
						</pre>

						<aside class="notes">
							<p>typeof provides rudimentary support for determining a variable's type</p>
							<p>As the MDN docs say "typeof is very useful, but it's not as versatile as might be required.". This is due to typeof often returning different things depending on how a value was created or how JavaScript represents other types internally.</p>
							<p>MDN also provides an alternative implementation but I typically use lodash since I already have a dependency on it.</p>
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h2>Revised Reflection/Introspection</h2>
						<h4>Same tricks, newer API</h4>
					</section>

					<section>
						<h2>Enumerating Properties</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers="6">
								const myObject = {
									firstName: "Dave",
									lastName: "Fancher"
								};

								Object.getOwnPropertyNames(myObject); // [ "firstName", "lastName" ]
							</code>
						</pre>
					</section>

					<section>
						<h2>Defining Properties</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers="6-12,14-20,22-29">
								const myObject = {
									firstName: "Dave",
									lastName: "Fancher"
								};

								void Object.defineProperty(
									myObject,
									"age",
									{
										enumerable: true,
										value: 42
									});
								
								void Object.defineProperty(
									myObject,
									"middleName",
									{
										enumerable: false,
										value: "William"
									});

								/*
								{
									firstName: "Dave",
									lastName: "Fancher",
									age: 42,
									middleName: "William"
								}
								*/
							</code>
						</pre>

						<aside class="notes">
							<ul>Object.defineProperty adds (or modifies) a property and returns the object it affected</ul>
						</aside>
					</section>

					<section>
						<h2>Property Descriptors</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers="6,8-15">
								const myObject = {
									firstName: "Dave",
									lastName: "Fancher"
								};

								Object.getOwnPropertyDescriptor(myObject, "firstName");

								/*
								{
									value: 'Dave',
									writable: true,
									enumerable: true,
									configurable: true
								}
								*/
							</code>
						</pre>

						<aside class="notes">
							<p>Metadata about each property including the value, whether the property should be included for enumeration, whether the property descriptor can be changed, and even middleware functions for intercepting (trapping) gets/sets</p>
						</aside>
					</section>

					<section>
						<h2>Enumerating Properties Revisited</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers="16-17|19-20">
								const myObject = {
									firstName: "Dave",
									lastName: "Fancher"
								};

								void Object.defineProperty(
									myObject,
									"age",
									{ enumerable: true, value: 42 });
								
								void Object.defineProperty(
									myObject,
									"middleName",
									{ enumerable: false, value: "William" });

								Object.getOwnPropertyNames(myObject);
								// [ "firstName", "lastName", "age", "middleName" ]
								
								Object.keys(myObject);
								// [ "firstName", "lastName", "age" ]
							</code>
						</pre>
					</section>

					<section>
						<h2>A Cautionary Tale... (Part 1)</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers>
								const err = Error("Fail");

								err.message; // ?
								err.stack; // ?

								JSON.stringify(err); // ?
							</code>
						</pre>
					</section>

					<section>
						<h2>A Cautionary Tale... (Part 2)</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers>
								const err = Error("Fail");

								err.message; // "Fail"
								err.stack; // "Error: Fail\n   at...""

								JSON.stringify(err); // "{}"
							</code>
						</pre>
					</section>

					<section>
						<h2>A Cautionary Tale... (Part 3)</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers>
								const err = Error("Fail");

								Object.getOwnPropertyDescriptors(err);

								/*
								{
									stack: 
									{
										value: 'Error: Fail\n    at...',
										writable: true,
										enumerable: false,
										configurable: true
									},
								    message: 
									{
										value: 'Fail',
										writable: true,
										enumerable: false,
										configurable: true
									}
								}
								*/
							</code>
						</pre>
					</section>

					<section>
						<h2>Enumerating Property Values</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers="7">
								const myObject = {
									firstName: "Dave",
									lastName: "Fancher",
									age: 42
								};

								Object.values(myObject); // [ "Dave", "Fancher", 42 ]
							</code>
						</pre>

						<aside class="notes">
							Object.values returns an array of all of the property values within an object in the order in which they're defined
						</aside>
					</section>

					<section>
						<h2>Objects as Key/Value Pairs</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers="16-17">
								const myObject = {
								    firstName: "Dave",
								    lastName: "Fancher"
								};

								void Object.defineProperty(
									myObject,
									"age",
									{ enumerable: true, value: 42 });

								void Object.defineProperty(
									myObject,
									"middleName",
									{ enumerable: false, value: "William" });

								Object
								    .entries(myObject)
								    .map(([ k, v ]) => `${k} is ${v}`)
								    .join("; ");
									
								// firstName is Dave; lastName is Fancher; age is 42
							</code>
						</pre>

						<aside class="notes">
							Essentially a combination of Object.keys and Object.values, Object.entries gets an array of the own key/value pairs from an object
						</aside>
					</section>

					<section>
						<h2>Objects from Key/Value Pairs</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers="16-17">
								const entries = [
								    [ "firstName", "Dave" ],
								    [ "lastName", "Fancher" ],
								    [ "age", 42 ]
								];

								Object.fromEntries(entries);

								/*
								{
									firstName: "Dave",
									lastName: "Fancher",
									age: 42
								}
								*/
							</code>
						</pre>
					</section>

					<section>
						<h2>Cloning Objects</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers=>
								const myObject = {
									firstName: "Dave",
									lastName: "Fancher"
								};

								// The target object is the first argument
								const myClone =
									Object.assign(
										{},
										myObject);

								/*
								{
									firstName: "Dave",
									lastName: "Fancher"
								}
								*/
							</code>
						</pre>

						<aside class="notes">
							<ul>
								<li>Copies <em>only</em> enumerable properties!</li>
								<li>Not suitable for deep cloning since references a copied</li>
							</ul>
						</aside>
					</section>

					<section>
						<h2>Merging Objects</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers>
								const myObject = {
								    firstName: "Dave",
								    lastName: "Fancher"
								};
								
								const myAddress = {
								    address: { city: "Carmel", state: "IN" }
								};

								Object.assign(
								    myObject,
								    { firstName: "David", age: 42 },
								    myAddress);

								/*
								{
									firstName: "David",
									lastName: "Fancher",
									age: 42,
									address: {
										city: "Indianapolis",
										state: "IN"
									}
								}
								*/
							</code>
						</pre>

						<aside class="notes">
							<ul>
								<li>Copies <em>only</em> enumerable properties!</li>
								<li>Not suitable for deep cloning since references a copied</li>
							</ul>
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h2>Modern Reflection/Introspection</h2>
						<h4>Same Tricks, Even Newer API</h4>

						<aside class="notes">
							The Reflect type exposes a modern, unified API for reflection and introspection
						</aside>
					</section>

					<section>
						<h2>Defining Properties</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers>
								const myObject = {
									firstName: "Dave",
									lastName: "Fancher"
								};

								Reflect.defineProperty(
									myObject,
									"age",
									{
										configurable: true,
										enumerable: true,
										writable: true
										value: 42,
									});

								/*
								{
									firstName: "Dave",
									lastName: "Fancher",
									age: 42
								}
								*/
							</code>
						</pre>

						<aside class="notes">
							One significant way that Reflect.defineProperty differs from Object.defineProperty is that Object.defineProperty throws an error if the operation fails whereas Reflect.defineProperty returns false.
						</aside>
					</section>

					<section>
						<h2>Deleting Properties</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers>
								const myObject = {
								    firstName: "Dave",
								    lastName: "Fancher",
									age: 42
								};
								
								void Reflect.deleteProperty(myObject, "age");									
							</code>
						</pre>
					</section>

					<section>
						<h2>Accessing/Mutating Properties</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers="6-7">
								const myObject = {
									firstName: "Dave",
									lastName: "Fancher"
								};

								Reflect.set(myObject, "firstName", "David");
								Reflect.get(myObject, "firstName");
							</code>
						</pre>
					</section>

					<section>
						<h2>Enumerating Properties</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers="1-12|11-12">
								const myObject = {
									firstName: "Dave",
									lastName: "Fancher"
								};

								Object.defineProperty(
									myObject,
									"age",
									{ enumerable: false, value: 42 });

								Reflect.ownKeys(myObject);
								// [ "firstName", "lastName", "age" ]
							</code>
						</pre>

						<aside class="notes">
							<ul>
								<li>Similar to Object.getOwnPropertyNames</li>
								<li>Includes <em>all</em> property names regardless of the enumerable setting</li>
								<li>Also includes <em>Symbols</em> which are covered later</li>
							</ul>
						</aside>
					</section>

					<section>
						<h2>Detecting Properties</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers="1-13|6|13">
								const myObject = {
								    firstName: "Dave",
								    lastName: "Fancher"
								};

								Reflect.has(myObject, "age"); // false

								Object.defineProperty(
									myObject,
									"age",
									{ enumerable: false, value: 42 });

								Reflect.has(myObject, "age"); // true
							</code>
						</pre>

						<aside class="notes">
							Returns true or false regardless of the enumerable descriptor
						</aside>
					</section>
				</section>

				<section>
					<h2>A Practical Example - Validation</h2>

					<pre>
						<code class="javascript" data-trim data-noescape data-line-numbers="1-51|1-16|2,5-7|9-10|12,14|18-21|30-35|37-41|43|45-49|51">
							const validateModel =
								validationModel =>
									model => {
										const failures =
											Reflect
												.ownKeys(validationModel)
												.reduce(
													(acc, key) => {
														const validate = validationModel[key];
														const value = model[key];
							
														if (!validate(value)) acc.push(key);
							
														return acc;
													},
													[]);
							
										if (failures.length > 0) {
											const errors = failures.join(", ");
											throw new Error(`Validation failures: ${errors}`);
										}

										return model;
									};
							
							const isNonEmptyString =
								value =>
									_.isString(value) && value.length > 0;
							
							const validatePersonModel =
								validateModel({
									firstName: isNonEmptyString,
									lastName: isNonEmptyString,
									age: _.isNumber
								});
							
							validatePersonModel({
								firstName: "Dave",
								lastName: "Fancher",
								age: 42
							});

							// { firstName: 'Dave', lastName: 'Fancher', age: 42 }
							
							validatePersonModel({
								firstName: "Dave",
								lastName: null,
								age: "42"
							});

							// Validation failures: lastName, age
						</code>
					</pre>
				</section>

				<section>
					<section>
						<h2>Symbols</h2>
						<h4>Collision-free Extension Points</h4>

						<aside class="notes">
							<ul>
								<li>Symbols are an interesting built-in type in that they're guaranteed to be unique when created with the Symbol constructor.</li>
								<li>They're also the basis for several built-in features</li>
							</ul>
						</aside>
					</section>

					<section>
						<h2>Defining Symbols</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers>
								// No Label
								const mySymbol1 = Symbol();
								
								// Label
								const mySymbol2 = Symbol("test");
							</code>
						</pre>

						<aside class="notes">
							<ul>
								<li>Symbols will still be unique when created with a label. The label's only purpose is to help identify the symbols when debugging.</li>
							</ul>
						</aside>
					</section>

					<section>
						<h2>Global Symbols</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers>
								const globalSymbol = Symbol.for("myGlobalSymbol");

								globalSymbol === Symbol.for("myGlobalSymbol"); // true
								
								Symbol.keyFor(globalSymbol); // myGlobalSymbol								
							</code>
						</pre>

						<aside class="notes">
							<ul>
								<li>Symbols can be registered within the Global Symbol Registry so they can be easily shared across your code base and referenced by a known key.</li>
								<li>We register a global symbol with the Symbol.for function.</li>
								<li>If a symbol does not exist in the GSR for a given key one will be created</li>
							</ul>
						</aside>
					</section>

					<section>
						<h2>Using Symbols - A Contrived Example</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers="1|11|14">
								const greet = Symbol("greet");

								const sayHello =
									function () {
										return `Hello, ${this.firstName} ${this.lastName}!`;
									};
								
								const myObject = {
									firstName: "Dave",
									lastName: "Fancher",
									[greet]: sayHello
								};
								
								myObject[greet](); // Hello, Dave Fancher!
							</code>
						</pre>

						<aside class="notes">
							We can attach symbols in object literals as computed properties. We access them similarly through the bracket notation.
						</aside>
					</section>

					<section>
						<h2>Well-Known Symbols</h2>

						<ul>
							<li class="fragment">Drive many built-in features</li>
							<li class="fragment">Allow customizing built-in behavior for specific types</li>
							<li class="fragment">
								Some well-known Symbols

								<div style="display: flex; flex-flow: row wrap; color: white;">
									<div class="fragment" style="flex: 1 1 50%;">Symbol.hasInstance</div>
									<div class="fragment" style="flex: 1 1 50%;">instanceof</div>

									<div class="fragment" style="flex: 1 1 50%">Symbol.iterator</div>
									<div class="fragment" style="flex: 1 1 50%">for..of</div>

									<div class="fragment" style="flex: 1 1 50%">Symbol.split</div>
									<div class="fragment" style="flex: 1 1 50%">String.prototype.split</div>

									<div class="fragment" style="flex: 1 1 50%">Symbol.toStringTag</div>
									<div class="fragment" style="flex: 1 1 50%">Object.prototype.toString</div>
								</div>
							</li>
						</ul>
					</section>

					<section>
						<h2>Customizing Behavior</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers="1-17|6|8-15|17">
								const myObject = {
									firstName: "Dave",
									lastName: "Fancher",
								};
								
								myObject.toString(); // [object Object]
								
								Reflect.defineProperty(
									myObject,
									Symbol.toStringTag,
									{
										get: function () {
											return `"${this.firstName} ${this.lastName}"`;
										}
									});
								
								myObject.toString(); // [object "Dave Fancher"]
							</code>
						</pre>
					</section>

					<section>
						<h2>Extending Built-in Objects</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers="26-36|1-17|2-3|4|6-14|16|19-20|22-24|26-36">
								const attachSymbol =
									target =>
										fn => {
											const sym = Symbol();
								
											void Reflect.defineProperty(
												target,
												sym,
												{
													enumerable: false,
													writable: false,
													configurable: false,
													value: fn
												});
								
											return sym;
										};
								
								const attachSymbolToObjectPrototype =
									attachSymbol(Object.prototype);
								
								const PIPE =
									attachSymbolToObjectPrototype(
										function (fn) { return fn(this); });
								
								({
									firstName: "Dave",
									lastName: "Fancher"
								})
									[PIPE](o => ({
										fname: o.firstName,
										lname: o.lastName,
										time: new Date()
									}))
									[PIPE](o => `[${o.time.toISOString()}] ${o.lname}, ${o.fname}`)
									[PIPE](s => s.toUpperCase()); //?
							</code>
						</pre>
					</section>
				</section>

				<section>
					<section>
						<h2>Intercession</h2>
						<h4>Intercepting Behavior</h4>
					</section>

					<section>
						<h2>Dynamic Objects</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers="1-55|1|20-27|25|5-10|26|12-18|29-36|38-47|50|52-53|55-56|58-61|63-71">
								function AuditedObject () {
									const context = {};
									const log = [];
								
									const __getTrap =
										property =>
											() => {
												console.log(`Getting context.${property}`);
												return Reflect.get(context, property);
											};
								
									const __setTrap =
										property =>
											value => {
												console.log(`Setting context.${property} to ${value}`);
												Reflect.set(context, property, value);
												log.push({ key: property, value, timestamp: new Date() });
											};
								
									Object.defineProperty(
										this,
										"firstName",
										{
											enumerable: true,
											get: __getTrap("firstName"),
											set: __setTrap("firstName")
										});
								
									Object.defineProperty(
										this,
										"lastName",
										{
											enumerable: true,
											get: __getTrap("lastName"),
											set: __setTrap("lastName")
										});
								
									Object.defineProperty(
										this,
										"history",
										{
											enumerable: true,
											get () {
												console.log("Getting context history");
												return log;
											}
										});
								};

								const myObject = new AuditedObject();

								myObject.firstName = "Dave";
								// Setting context.firstName to Dave

								myObject.lastName = "Fancher";
								// Setting context.lastName to Fancher

								`${myObject.firstName} ${myObject.lastName}`;
								// Getting context.firstName
								// Getting context.lastName
								// Dave Fancher

								myObject
									.history
									.map(h => `[${h.timestamp.toISOString()}] ${h.value} -> ${h.key}`);
								/*
									[
										'[2022-08-06T03:33:59.614Z] Dave -> firstName',
										'[2022-08-06T03:33:59.615Z] Fancher -> lastName'
									]
								*/
							</code>
						</pre>
					</section>

					<section>
						<h2>Simple Proxy</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers="1-24|1-2|5|2,6|7-23|8-12|13-22|26|28-29|31-32|34-37|39-47">
								const auditObject =
									obj => {
										const log = [];
								
										return new Proxy(
											obj,
											{
												get (target, key) {
													console.log(`Getting ${key} from target`);
													if (key === "history") return log;
													return Reflect.get(target, key);
												},
												set (target, key, value) {
													if (key === "history") {
														console.log("Cannot rewrite history");
														return;
													}
								
													console.log(`Setting ${key} to ${value} on target`);
													Reflect.set(target, key, value);
													log.push({ key, value, timestamp: new Date() });
												}
											});
									};
								
								const myObject = auditObject({});
								
								myObject.firstName = "Dave";
								// Setting firstName to Dave on target
								
								myObject.lastName = "Fancher";
								// Setting lastName to Fancher on target
								
								`${myObject.firstName} ${myObject.lastName}`; //?
								// Getting firstName from target
								// Getting lastName from target
								// Dave Fancher
								
								myObject
									.history
									.map(h => `[${h.timestamp.toISOString()}] ${h.value} -> ${h.key}`); //?
								/*
								[
									'[2022-08-06T03:45:25.174Z] Dave -> firstName',
									'[2022-08-06T03:45:25.174Z] Fancher -> lastName'
								]
								*/
							</code>
						</pre>
					</section>

					<section>
						<h2>More Traps</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers="8,13|23-30|31-34">
								const auditObject =
									obj => {
										const log = [];
								
										return new Proxy(
											obj,
											{
												get (target, key) {
													console.log(`Getting ${key} from target`);
													if (key === "history") return log;
													return Reflect.get(target, key);
												},
												set (target, key, value) {
													if (key === "history") {
														console.log("Cannot rewrite history");
														return;
													}
								
													console.log(`Setting ${key} to ${value} on target`);
													Reflect.set(target, key, value);
													log.push({ key, value, timestamp: new Date() });
												},
												deleteProperty (target, key) {
													if (key === "history") {
														throw new TypeError("Trying to delete history? Really?");
													}
								
													console.log(`Deleting ${key} from target`);
													Reflect.deleteProperty(target, key);
												},
												has (target, key) {
													console.log(`Looking for ${key} in target`);
													return key === "history" || Reflect.has(target, key);
												}
											}
										);
									};
							</code>
						</pre>
					</section>
				</section>

				<section>
					<div style="display: flex; flex-direction: row; align-items: flex-end;">
						<div style="flex: 1 1 300px">
							<img src="./assets/qrcode_davefancher.github.io.png">
						</div>
						<div style="flex: 1 1 300px; text-align: left; padding-left: 20px;">
							<h2>Thank You!</h2>

							<p style="font-size: 0.5em">
								Dave Fancher<br />
								Lead Software Engineer - Vibenomics
							</p>
							<hr />
							<p style="font-size: 0.5em">
								Twitter: @davefancher<br />
								LinkedIn: davefancher
							</p>
						</div>
					</div>
				</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
