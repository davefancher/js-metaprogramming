<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>JavaScript Metaprogramming</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/moon.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h2>JavaScript Metaprogramming</h2>
					<hr />
					<h3>
						Dave Fancher<br />
						<span style="font-size: .5em; opacity: 50%;">
							Lead Software Engineer - Vibenomics
						</span>
					</h3>
				</section>

				<!-- <section>
					<img src="" />
				</section> -->

				<section>
					<h2>About This Presentation</h2>
					<ul>
						<li class="fragment">Covers a wide range of JavaScript's metaprogramming capabilities</li>
						<li class="fragment">Not intended to be comprehensive</li>
						<li class="fragment">Node.js-centric (v14)</li>
						<li class="fragment">Current project makes extensive use of metaprogramming techniques</li>
						<li class="fragment">My background</li>
					</ul>

					<aside class="notes">
						<ul>
							<li>Programming for ~20 years</li>
							<li>
								Traditionally in MS technologies
								<ul>
									<li>Mostly .NET</li>
									<li>C#</li>
									<li>F#</li>
								</ul>
							</li>
							<li>JS for the past ~4 years</li>
							<li>Node.js</li>
						</ul>
					</aside>
				</section>

				<section>
					<h2>What is Metaprogramming?</h2>
					<ul>
						<li class="fragment">Programming about programming/Code about code</li>
						<li class="fragment">
							3 Categories
							<ul>
								<li class="fragment">Code Generation - Code writing code</li>
								<li class="fragment">Reflection - Interrogation and manipulation</li>
								<li class="fragment">Intercession - Intercepting behavior</li>
							</ul>
						</li>						
					</ul>

					<aside class="notes">
						<ul>
							<li>Most have been available in JS since its early days</li>
						</ul>
					</aside>
				</section>

				<section>
					<section>
						<h2>Code Generation</h2>
						<h4>Code writing code</h4>
					</section>					

					<section>
						<h2>eval (ugh...)</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers>
								const sayHello =
								    eval("name => `[eval] Hello, ${name}!`;");

								sayHello("Dave"); // [eval] Hello, Dave!
							</code>
						</pre>

						<aside class="notes">
							<ul>
								<li>Scoping issues</li>
								<li>executes the code it's passed with the privileges of the caller</li>
								<li>Slower than alternatives</li>
								<li>More covered in detail elsewhere...</li>
							</ul>
						</aside>
					</section>

					<section>
						<h2>eval - Scope/Access Issues</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers>
								const name = "Dave";

								const sayHello =
								    eval("() => `[eval] Hello, ${name}`");

								sayHello();	// [eval] Hello, Dave!
							</code>
						</pre>
					</section>

					<section>
						<h2>Function Constructor</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers>
								const sayHello =
								    new Function(
								        "name",
								        "return `[func] Hello, ${name}!`");

								sayHello("Dave"); // [func] Hello, Dave!
							</code>
						</pre>

						<aside class="notes">
							<ul>
								<li>Improvement over eval</li>
								<li>Functions created this way don't close around the context</li>
								<li>These are in the global scope</li>
							</ul>
						</aside>
					</section>

					<section>
						<h2>Function Constructor - Global Scope</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers>
								const sayHello =
								    new Function(
								        "return `[func] Hello, ${name}`");

								const name = "Dave";

								sayHello();  // ?
							</code>
						</pre>
					</section>

					<section>
						<h2>Function Constructor - Global Scope</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers>
								const sayHello =
								    new Function(
								        "return `[func] Hello, ${name}`");

								const name = "Dave";

								sayHello();  // ReferenceError: name is not defined
							</code>
						</pre>
					</section>

					<section>
						<h2>Function Constructor - Global Scope</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers>
								const sayHello =
								    new Function(
								        "return `[func] Hello, ${name}`");

								global.name = "Dave";

								sayHello();  // [func] Hello, Dave
							</code>
						</pre>
					</section>

					<section>
						<h2>Function Constructor - Parameters</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers>
								const sayHello =
									new Function(
										"name", "return `[func] Hello, ${name}`");

								sayHello("Dave"); // [func] Hello, Dave
							</code>
						</pre>
					</section>

					<section>
						<h2>vm Module (Node.js)</h2>
						
						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers="1-17|1|5-8|10-11,13-14|16-17|3|16-17">
								const vm = require("node:vm");

								global.scopeName = "global";

								const script =
									new vm.Script(
										"name => `[vm - ${scopeName} context] Hello, ${name}`;"
									);
								
								const sayHelloThisContext =
									script.runInThisContext();

								const sayHelloNewContext =
									script.runInNewContext({ scopeName: "new" });
								
								sayHelloThisContext("Dave"); // [vm - global context] Hello, Dave
								sayHelloNewContext("Dave");  // [vm - new context] Hello, Dave
							</code>
						</pre>

						<aside class="notes">
							<ul>
								<li>V8 Virtual Machine</li>
								<li>Allows running code in a separate global context</li>
							</ul>
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h2>Reflection/Introspection</h2>

						<h4>Interrogate and Manipulate</h4>
					</section>

					<section>
						<h2>Type Detection...maybe</h2>
	
						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers>
								// Numbers
								typeof 37;                  // number
								typeof Number(37);          // number
								typeof new Number(37);      // object
								typeof NaN;                 // number
								typeof Number("nope");      // number
								
								// Strings
								typeof "Hello";             // string
								typeof String("Hello");     // string
								typeof new String("Hello"); // object
	
								// Booleans
								typeof true;                // boolean
								typeof Boolean(1);          // boolean
								typeof new Boolean(1);      // object
	
								// Date
								typeof new Date();          // object
								
								// Arrays
								typeof [ 1, 2, 3 ];         // object
								
								// nils
								typeof null;                // object
								typeof undefined;           // undefined
								
								// functions
								typeof (function (name) {
									return `Hello, ${name}`;
								});                         // function
								
								typeof (name => `Hello, ${name}`);  // function
							</code>
						</pre>

						<aside class="notes">
							<p>typeof provides rudimentary support for determining a variable's type</p>
							<p>As the MDN docs say "typeof is very useful, but it's not as versatile as might be required.". This is due to typeof often returning different things depending on how a value was created or how JavaScript represents other types internally.</p>
							<p>MDN also provides an alternative implementation but I typically use lodash since I already have a dependency on it.</p>
						</aside>
					</section>					
				</section>

				<section>
					<section>
						<h2>Simple (Classic) Reflection</h2>
					</section>

					<section>
						<h2>Detecting Properties</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers>
								const myObject = {
									firstName: "Dave",
									lastName: "Fancher",
									age: 43
								};
	
								"firstName" in myObject;  // true
								"lastName" in myObject;   // true
								"middleName" in myObject; // false
							</code>
						</pre>
					</section>

					<section>
						<h2>Defining Properties</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers>
								const myObject = {
									firstName: "Dave",
									lastName: "Fancher"
								};

								myObject.age = 43;
								myObject["birthdate"] = "1979-12-19";
							</code>
						</pre>
					</section>

					<section>
						<h2>Enumerating Properties</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers>
								const myObject = {
									firstName: "Dave",
									lastName: "Fancher",
									age: 43
								};

								const allAttrs = [];

								for (attr in myObject) {
									allAttrs.push(attr);
								}

								// [ "firstName", "lastName", "age" ]
							</code>
						</pre>
					</section>

					<section>
						<h2>Copying Values</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers>
								const myObject = {
									firstName: "Dave",
									lastName: "Fancher",
									age: 43
								};

								const newObj = {};
								for (attr in myObject) {
									newObj[attr] = myObject[attr];
								}

								/* {
									firstName: "Dave",
									lastName: "Fancher",
									age: 43
								} */
							</code>
						</pre>
					</section>

					<section>
						<h2>Removing Properties</h2>
	
						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers>
								const myObject = {
									firstName: "Dave",
									lastName: "Fancher",
									age: 43
								};
	
								delete myObject.age;        // true
								delete myObject.middleName; // true
	
								"firstName" in myObject;    // true
								"lastName" in myObject;     // true
								"age" in myObject;          // false
							</code>
						</pre>
					</section>
				</section>

				<section>
					<section>
						<h2>Modern Reflection</h2>

						<aside class="notes">
							<ul>
								<li>Reflect type improves upon the Object methods</li>
								<li>Consistent interface with Proxy type</li>
							</ul>
						</aside>
					</section>

					<section>
						<h2>Detecting Properties</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers="1-13|6|13">
								const myObject = {
								    firstName: "Dave",
								    lastName: "Fancher"
								};

								Reflect.has(myObject, "age"); // false

								Object.defineProperty(
									myObject,
									"age",
									{ enumerable: false, value: 43 });

								Reflect.has(myObject, "age"); // true
							</code>
						</pre>

						<aside class="notes">
							Returns true or false regardless of the enumerable descriptor
						</aside>
					</section>

					<section>
						<h2>Accessing/Mutating Properties</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers="6-7">
								const myObject = {
									firstName: "Dave",
									lastName: "Fancher"
								};

								Reflect.set(myObject, "firstName", "David");
								Reflect.get(myObject, "firstName");
							</code>
						</pre>
					</section>

					<section>
						<h2>Defining Properties - Computed Names</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers>
								const DEVICE_IDENTIFIERS = Object.freeze({
									PLAYER_ID: "playerId",
									MAC_ADDRESS: "macAddress",
									PHONE_NUMBER: "phoneNumber",
									SERIAL_NUMBER: "serialNumber"
								});

								const identifierValidators = {
									[DEVICE_IDENTIFIERS.MAC_ADDRESS]: validateMACAddress,
									[DEVICE_IDENTIFIERS.PHONE_NUMBER]: validatePhoneNumber,
									[DEVICE_IDENTIFIERS.PLAYER_ID]: validatePlayerId,
									[DEVICE_IDENTIFIERS.SERIAL_NUMBER]: validateSerialNumber
								};
							</code>
						</pre>

						<aside class="notes">
							ES6 feature - we'll come back to this in a bit
						</aside>
					</section>

					<section>
						<h2>Defining Properties</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers="1-4|6-14|16-22|24-32|34-41">
								const myObject = {
									firstName: "Dave",
									lastName: "Fancher"
								};

								Reflect.defineProperty(
									myObject,
									"age",
									{
										configurable: true,
										enumerable: true,
										writable: true,
										value: 43,
									}); // true

								/*
								{
									firstName: "Dave",
									lastName: "Fancher",
									age: 43
								}
								*/

								Object.defineProperty(
									myObject,
									"birthDate",
									{
										configurable: true,
										enumerable: true,
										writable: true,
										value: "1979-12-19"
									}); // {{myObject}}

								/*
								{
									firstName: 'Dave',
									lastName: 'Fancher',
									age: 43,
									birthDate: '1979-12-19'
								}
								*/
							</code>
						</pre>

						<aside class="notes">
							<ul>
								<li>One significant way that Reflect.defineProperty differs from Object.defineProperty is that Object.defineProperty throws an error if the operation fails whereas Reflect.defineProperty returns false.</li>
								<li>Object has additional methods for defining multiple properties</li>
							</ul>
						</aside>
					</section>

					<section>
						<h2>Getting Property Descriptors</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers>
								const myObject = {
									firstName: "Dave",
									lastName: "Fancher"
								};
								
								Reflect.getOwnPropertyDescriptor(myObject, "firstName");

								/*
								{
									value: 'Dave',
									writable: true,
									enumerable: true,
									configurable: true
								}
								*/
							</code>
						</pre>

						<aside class="notes">
							The Object type has a method to get all property descriptors, Reflect does not.
						</aside>
					</section>

					<section>
						<h2>Enumerating Properties</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers="1-14|16-17|19-20|22-23">
								const myObject = {
									firstName: "Dave",
									lastName: "Fancher"
								};
								
								Reflect.defineProperty(
									myObject,
									"age",
									{
										configurable: true,
										enumerable: false,
										writable: true,
										value: 43,
									});

								Reflect.ownKeys(myObject);
								// [ 'firstName', 'lastName', 'age' ]

								Object.getOwnPropertyNames(myObject); //?
								// [ 'firstName', 'lastName', 'age' ]

								Object.keys(myObject);
								// [ 'firstName', 'lastName' ]
							</code>
						</pre>
					</section>

					<section data-transition="fade-out">
						<h2>A Cautionary Tale... (Part 1)</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers>
								const err = Error("Fail");

								err.message; // ?
								err.stack; // ?

								JSON.stringify(err); // ?
							</code>
						</pre>
					</section>

					<section data-transition="fade-in">
						<h2>A Cautionary Tale... (Part 1)</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers>
								const err = Error("Fail");

								err.message; // "Fail"
								err.stack; // "Error: Fail\n   at...""

								JSON.stringify(err); // "{}"
							</code>
						</pre>
					</section>

					<section>
						<h2>A Cautionary Tale... (Part 2)</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers>
								const err = Error("Fail");

								Object.getOwnPropertyDescriptors(err);

								/*
								{
									stack: 
									{
										value: 'Error: Fail\n    at...',
										writable: true,
										enumerable: false,
										configurable: true
									},
								    message: 
									{
										value: 'Fail',
										writable: true,
										enumerable: false,
										configurable: true
									}
								}
								*/
							</code>
						</pre>
					</section>

					<section>
						<h2>A Cautionary Tale... (Part 3)</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers="3-6,8-11|13|15-17">
								const err = Error("Fail");

								void Reflect.defineProperty(
									err,
									"message",
									{ enumerable: true });

								void Reflect.defineProperty(
									err,
									"stack",
									{ enumerable: true });
 
								JSON.stringify(err);

								/*
								{ "stack":"Error: Fail\n    at...", "message":"Fail" }
								*/
							</code>
						</pre>
					</section>

					<section>
						<h2>Deleting Properties</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers="1-4,6-7|9-11,14,19">
								const myObject = {
									firstName: "Dave",
									lastName: "Fancher",
								};
																
								Reflect.deleteProperty(myObject, "age"); // true
								Reflect.deleteProperty(myObject, "ethnicity"); // true

								void Reflect.defineProperty(
									myObject,
									"birthdate",
									{
										value: "1979-12-19",
										configurable: false,
										enumerable: true,
										writable: false,
									});

								Reflect.deleteProperty(myObject, "birthdate"); // false
							</code>
						</pre>
					</section>

					<section>
						<h2>Enumerating Property Values</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers="7">
								const myObject = {
									firstName: "Dave",
									lastName: "Fancher",
									age: 43
								};

								Object.values(myObject); // [ "Dave", "Fancher", 43 ]
							</code>
						</pre>

						<aside class="notes">
							Object.values returns an array of all of the property values within an object in the order in which they're defined
						</aside>
					</section>

					<section>
						<h2>Enumerating Property Values</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers="1-6|8|10-11">
								const DEVICE_IDENTIFIERS = Object.freeze({
									PLAYER_ID: "playerId",
									MAC_ADDRESS: "macAddress",
									PHONE_NUMBER: "phoneNumber",
									SERIAL_NUMBER: "serialNumber"
								});

								const validIdentifiers = Object.values(DEVICE_IDENTIFIERS)
								
								validIdentifiers.includes("playerId"); // true
								validIdentifiers.includes("imei"); // false
							</code>
						</pre>
					</section>

					<section>
						<h2>Property Value Enumeration with Computed Property Names</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers="1-6|8-13|15-22|9,17-22|10,17-22|11,17-22|12,17-22">
								const DEVICE_IDENTIFIERS = Object.freeze({
									PLAYER_ID: "playerId",
									MAC_ADDRESS: "macAddress",
									PHONE_NUMBER: "phoneNumber",
									SERIAL_NUMBER: "serialNumber"
								});

								const identifierFormatters = {
									[DEVICE_IDENTIFIERS.MAC_ADDRESS]: formatMACAddress,
									[DEVICE_IDENTIFIERS.PHONE_NUMBER]: formatPhoneNumber,
									[DEVICE_IDENTIFIERS.PLAYER_ID]: formatPlayerId,
									[DEVICE_IDENTIFIERS.SERIAL_NUMBER]: formatSerialNumber
								};

								Object
									.values(DEVICE_IDENTIFIERS)
									.forEach(identifier => {
										if (Reflect.has(model, identifier)) {
											const format = identifierFormatters[identifier];
											model[identifier] = format(model[identifier]);
										}
									});
							</code>
						</pre>

						<aside class="notes">
							ES6 feature
						</aside>
					</section>

					<section>
						<h2>Objects as Key/Value Pairs</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers="16-17">
								const myObject = {
								    firstName: "Dave",
								    lastName: "Fancher"
								};

								void Object.defineProperty(
									myObject,
									"age",
									{ enumerable: true, value: 43 });

								void Object.defineProperty(
									myObject,
									"middleName",
									{ enumerable: false, value: "William" });

								Object
								    .entries(myObject)
								    .map(([ k, v ]) => `${k} is ${v}`)
								    .join("; ");
									
								// firstName is Dave; lastName is Fancher; age is 43
							</code>
						</pre>

						<aside class="notes">
							Essentially a combination of Object.keys and Object.values, Object.entries gets an array of the own key/value pairs from an object

							Combines nicely with the attribute pattern in MongoDB
						</aside>
					</section>

					<section>
						<h2>Objects from Key/Value Pairs</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers="16-17">
								const entries = [
								    [ "firstName", "Dave" ],
								    [ "lastName", "Fancher" ],
								    [ "age", 43 ]
								];

								Object.fromEntries(entries);

								/*
								{
									firstName: "Dave",
									lastName: "Fancher",
									age: 43
								}
								*/
							</code>
						</pre>

						<aside class="notes">
							Also combines nicely with the attribute pattern in MongoDB
						</aside>
					</section>

					<section>
						<h2>Cloning Objects</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers=>
								const myObject = {
									firstName: "Dave",
									lastName: "Fancher"
								};

								// The target object is the first argument
								const myClone =
									Object.assign(
										{},
										myObject);

								/*
								{
									firstName: "Dave",
									lastName: "Fancher"
								}
								*/
							</code>
						</pre>

						<aside class="notes">
							<ul>
								<li>Copies <em>only</em> enumerable properties!</li>
								<li>Not suitable for deep cloning since references are copied</li>
							</ul>
						</aside>
					</section>

					<section>
						<h2>Merging Objects</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers="1-4,6-8|10-13,15-25">
								const myObject = {
								    firstName: "Dave",
								    lastName: "Fancher"
								};
								
								const myAddress = {
								    address: { city: "Indianapolis", state: "IN" }
								};

								Object.assign(
								    myObject,
								    { firstName: "David", age: 43 },
								    myAddress);

								/*
								{
									firstName: "David",
									lastName: "Fancher",
									age: 43,
									address: {
										city: "Indianapolis",
										state: "IN"
									}
								}
								*/
							</code>
						</pre>
					</section>
				</section>

				<section>
					<h2>A Practical Example - Validation</h2>

					<pre>
						<code class="javascript" data-trim data-noescape data-line-numbers="1-51|1-16|2,5-8|2,3,9-10|12,14|18-21|23|30-35|37-41,43|45-49,51">
							const validateModel =
								validationModel =>
									model => {
										const failures =
											Reflect
												.ownKeys(validationModel)
												.reduce(
													(acc, key) => {
														const validate = validationModel[key];
														const value = model[key];
							
														if (!validate(value)) acc.push(key);
							
														return acc;
													},
													[]);
							
										if (failures.length > 0) {
											const errors = failures.join(", ");
											throw new Error(`Validation failures: ${errors}`);
										}

										return model;
									};
							
							const isNonEmptyString =
								value =>
									_.isString(value) && value.length > 0;
							
							const validatePersonModel =
								validateModel({
									firstName: isNonEmptyString,
									lastName: isNonEmptyString,
									age: _.isNumber
								});
							
							validatePersonModel({
								firstName: "Dave",
								lastName: "Fancher",
								age: 43
							});

							// { firstName: 'Dave', lastName: 'Fancher', age: 43 }
							
							validatePersonModel({
								firstName: "Dave",
								lastName: null,
								age: "43"
							});

							// Validation failures: lastName, age
						</code>
					</pre>

					<p style="font-size: 10pt">Example requires lodash</p>
				</section>

				<section>
					<section>
						<h2>Symbols</h2>
						<h4>Collision-free Extension Points</h4>

						<aside class="notes">
							<ul>
								<li>Symbols are an interesting built-in type in that they're guaranteed to be unique when created with the Symbol constructor.</li>
								<li>They're also the basis for several built-in features</li>
							</ul>
						</aside>
					</section>

					<section>
						<h2>Defining Symbols</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers>
								// No Label
								const mySymbol1 = Symbol();
								
								// Label
								const mySymbol2 = Symbol("test");
							</code>
						</pre>

						<aside class="notes">
							<ul>
								<li>Symbols will still be unique when created with a label. The label's only purpose is to help identify the symbols when debugging.</li>
							</ul>
						</aside>
					</section>

					<section>
						<h2>Global Symbols</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers>
								const globalSymbol = Symbol.for("myGlobalSymbol");

								globalSymbol === Symbol.for("myGlobalSymbol"); // true
								
								Symbol.keyFor(globalSymbol); // myGlobalSymbol								
							</code>
						</pre>

						<aside class="notes">
							<ul>
								<li>Symbols can be registered within the Global Symbol Registry so they can be easily shared across your code base and referenced by a known key.</li>
								<li>We register a global symbol with the Symbol.for function.</li>
								<li>If a symbol does not exist in the GSR for a given key one will be created</li>
							</ul>
						</aside>
					</section>

					<section>
						<h2>Using Symbols - A Contrived Example</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers="1-14|1|11|14">
								const greet = Symbol("greet");

								const sayHello =
									function () {
										return `Hello, ${this.firstName} ${this.lastName}!`;
									};
								
								const myObject = {
									firstName: "Dave",
									lastName: "Fancher",
									[greet]: sayHello
								};
								
								myObject[greet](); // Hello, Dave Fancher!
							</code>
						</pre>

						<aside class="notes">
							We can attach symbols in object literals as computed properties. We access them similarly through the bracket notation.
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h2>Well-Known Symbols</h2>

						<ul>
							<li class="fragment">Drive many built-in features</li>
							<li class="fragment">Allow customizing built-in behavior for specific types</li>
							<li class="fragment">
								Some well-known Symbols

								<div style="display: flex; flex-flow: row wrap; color: white;">
									<div class="fragment" style="flex: 1 1 50%;">Symbol.hasInstance</div>
									<div class="fragment" style="flex: 1 1 50%;">instanceof</div>

									<div class="fragment" style="flex: 1 1 50%">Symbol.iterator</div>
									<div class="fragment" style="flex: 1 1 50%">for..of</div>

									<div class="fragment" style="flex: 1 1 50%">Symbol.split</div>
									<div class="fragment" style="flex: 1 1 50%">String.prototype.split</div>

									<div class="fragment" style="flex: 1 1 50%">Symbol.toStringTag</div>
									<div class="fragment" style="flex: 1 1 50%">Object.prototype.toString</div>

									<div class="fragment" style="flex: 1 1 50%">Symbol.toPrimitive</div>
									<div class="fragment" style="flex: 1 1 50%">{{type coersions}}</div>
								</div>
							</li>
						</ul>
					</section>

					<section>
						<h2>Customizing Behavior</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers="1-31|7|9-16|18|20-35|37-38">
								const myObject = {
									firstName: "Dave",
									lastName: "Fancher",
									age: 43
								};
								
								myObject.toString(); // [object Object]
								
								Reflect.defineProperty(
									myObject,
									Symbol.toStringTag,
									{
										get: function () {
											return `"${this.firstName} ${this.lastName}"`;
										}
									});

								myObject.toString(); // [object "Dave Fancher"]

								Reflect.defineProperty(
									myObject,
									Symbol.toPrimitive,
									{
										value: function (hint) {
											const { firstName, lastName, age } = this;

											if (hint === "number")
												return age;

											if (hint === "string")
												return `${firstName} ${lastName} (${age})`;

											return null;
										}
									});

								+myObject; // 43
								String(myObject); // Dave Fancher (43)
							</code>
						</pre>
					</section>
				</section>

				<section>
					<section>
						<h2>Extending Built-in Objects</h2>
						<h4>Using Custom Symbols for Collision-free Extensions</h4>
					</section>

					<section>
						<h2>Extending Built-in Objects</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers="26-36|1-17|2-3|4|6-14|16|19-20|22-24|26-36">
								const attachSymbol =
									target =>
										fn => {
											const sym = Symbol();
								
											void Reflect.defineProperty(
												target,
												sym,
												{
													enumerable: false,
													writable: false,
													configurable: false,
													value: fn
												});
								
											return sym;
										};
								
								const attachSymbolToObjectPrototype =
									attachSymbol(Object.prototype);
								
								const PIPE =
									attachSymbolToObjectPrototype(
										function (fn) { return fn(this); });
								
								({
									firstName: "Dave",
									lastName: "Fancher"
								})
									[PIPE](o => ({
										fname: o.firstName,
										lname: o.lastName,
										time: new Date()
									}))
									[PIPE](o => `[${o.time.toISOString()}] ${o.lname}, ${o.fname}`)
									[PIPE](s => s.toUpperCase());
							</code>
						</pre>
					</section>

					<section>
						<h2>Extending Built-in Objects</h2>
						<h4>Hiding this</h4>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers="1-39|13-15|26|29-39">
								const attachSymbol =
									target =>
										fn => {
											const sym = Symbol();
								
											void Reflect.defineProperty(
												target,
												sym,
												{
													enumerable: false,
													writable: false,
													configurable: false,
													value: function () {
														return fn(this)(...arguments);
													}
												});
								
											return sym;
										};
								
								const attachSymbolToObjectPrototype =
									attachSymbol(Object.prototype);
								
								const PIPE =
									attachSymbolToObjectPrototype(
										context => fn => fn(context)
									);
								
								({
									firstName: "Dave",
									lastName: "Fancher"
								})
									[PIPE](o => ({
										fname: o.firstName,
										lname: o.lastName,
										time: new Date()
									}))
									[PIPE](o => `[${o.time.toISOString()}] ${o.lname}, ${o.fname}`)
									[PIPE](s => s.toUpperCase());
							</code>
						</pre>
					</section>

					<section>
						<h2>Extending Built-in Objects</h2>
						<h4>Arrays</h4>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers="1-47|1-2|4-28|5-7|6,8,9|11-14|16-18|20-22,24,26|30-38,40-43|45-50|52-56|58-67">
								const attachSymbolToArrayPrototype =
									attachSymbol(Array.prototype);
								
								const GROUP_BY =
									attachSymbolToArrayPrototype(
										context =>
											(keySelector, valueSelector) =>
												context
													.reduce(
														(agg, item) => {
															const key =
																item
																	[PIPE](keySelector)
																	[PIPE](String);
										
															const value =
																item
																	[PIPE](valueSelector);
											
															if (!Reflect.has(agg, key)) {
																void Reflect.set(agg, key, []);
															}
								
															void Reflect.get(agg, key).push(value);
								
															return agg;
														},
														{}));

								const names =
									([
										{ fname: "Homer", lname: "Simpson" },
										{ fname: "Peter", lname: "Griffin" },
										{ fname: "Lois", lname: "Griffin" },
										{ fname: "Bart", lname: "Simpson" },
										{ fname: "Marge", lname: "Simpson" },
										{ fname: "Stewie", lname: "Griffin" },
									]);

								names
									[GROUP_BY](
										v => v.lname,
										v => v.fname);

								/*
								{
									Simpson: [ 'Homer', 'Bart', 'Marge' ],
									Griffin: [ 'Peter', 'Lois', 'Stewie' ]
								}
								*/

								const ID = x => x;
								names
									[GROUP_BY](
										v => v.lname,
										ID);

								/*
								{ Simpson: 
									[ { fname: 'Homer', lname: 'Simpson' },
									  { fname: 'Bart', lname: 'Simpson' },
									  { fname: 'Marge', lname: 'Simpson' } ],
								   Griffin: 
									[ { fname: 'Peter', lname: 'Griffin' },
									  { fname: 'Lois', lname: 'Griffin' },
									  { fname: 'Stewie', lname: 'Griffin' } ] }
								*/
							</code>
						</pre>
					</section>
					
				</section>

				<section>
					<section>
						<h2>Intercession</h2>
						<h4>Intercepting Behavior</h4>
					</section>

					<section>
						<h2>Dynamic Objects</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers="1-55|1|20-27|25|5-10|26|12-18|29-36|38-47|50|52-53|55-56|58-61|63-71">
								function AuditedObject () {
									const context = {};
									const log = [];
								
									const __getTrap =
										property =>
											() => {
												console.log(`Getting context.${property}`);
												return Reflect.get(context, property);
											};
								
									const __setTrap =
										property =>
											value => {
												console.log(`Setting context.${property} to ${value}`);
												Reflect.set(context, property, value);
												log.push({ key: property, value, timestamp: new Date() });
											};
								
									Object.defineProperty(
										this,
										"firstName",
										{
											enumerable: true,
											get: __getTrap("firstName"),
											set: __setTrap("firstName")
										});
								
									Object.defineProperty(
										this,
										"lastName",
										{
											enumerable: true,
											get: __getTrap("lastName"),
											set: __setTrap("lastName")
										});
								
									Object.defineProperty(
										this,
										"history",
										{
											enumerable: true,
											get () {
												console.log("Getting context history");
												return log;
											}
										});
								};

								const myObject = new AuditedObject();

								myObject.firstName = "Dave";
								// Setting context.firstName to Dave

								myObject.lastName = "Fancher";
								// Setting context.lastName to Fancher

								`${myObject.firstName} ${myObject.lastName}`;
								// Getting context.firstName
								// Getting context.lastName
								// Dave Fancher

								myObject
									.history
									.map(h => `[${h.timestamp.toISOString()}] ${h.value} -> ${h.key}`);
								/*
									[
										'[2022-08-06T03:33:59.614Z] Dave -> firstName',
										'[2022-08-06T03:33:59.615Z] Fancher -> lastName'
									]
								*/
							</code>
						</pre>
					</section>

					<section>
						<h2>Simple Proxy</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers="1-24|1-2|5|2,6|7-23|8-12|13-22|26|28-29|31-32|34-37|39-47">
								const auditObject =
									obj => {
										const log = [];
								
										return new Proxy(
											obj,
											{
												get (target, key) {
													console.log(`Getting ${key} from target`);
													if (key === "history") return log;
													return Reflect.get(target, key);
												},
												set (target, key, value) {
													if (key === "history") {
														console.log("Cannot rewrite history");
														return;
													}
								
													console.log(`Setting ${key} to ${value} on target`);
													Reflect.set(target, key, value);
													log.push({ key, value, timestamp: new Date() });
												}
											});
									};
								
								const myObject = auditObject({});
								
								myObject.firstName = "Dave";
								// Setting firstName to Dave on target
								
								myObject.lastName = "Fancher";
								// Setting lastName to Fancher on target
								
								`${myObject.firstName} ${myObject.lastName}`; //?
								// Getting firstName from target
								// Getting lastName from target
								// Dave Fancher
								
								myObject
									.history
									.map(h => `[${h.timestamp.toISOString()}] ${h.value} -> ${h.key}`); //?
								/*
								[
									'[2022-08-06T03:45:25.174Z] Dave -> firstName',
									'[2022-08-06T03:45:25.174Z] Fancher -> lastName'
								]
								*/
							</code>
						</pre>
					</section>

					<section>
						<h2>More Traps</h2>

						<pre>
							<code class="javascript" data-trim data-noescape data-line-numbers="8,13|23-30|31-34">
								const auditObject =
									obj => {
										const log = [];
								
										return new Proxy(
											obj,
											{
												get (target, key) {
													console.log(`Getting ${key} from target`);
													if (key === "history") return log;
													return Reflect.get(target, key);
												},
												set (target, key, value) {
													if (key === "history") {
														console.log("Cannot rewrite history");
														return;
													}
								
													console.log(`Setting ${key} to ${value} on target`);
													Reflect.set(target, key, value);
													log.push({ key, value, timestamp: new Date() });
												},
												deleteProperty (target, key) {
													if (key === "history") {
														throw new TypeError("Trying to delete history? Really?");
													}
								
													console.log(`Deleting ${key} from target`);
													Reflect.deleteProperty(target, key);
												},
												has (target, key) {
													console.log(`Looking for ${key} in target`);
													return key === "history" || Reflect.has(target, key);
												}
											}
										);
									};
							</code>
						</pre>
					</section>
				</section>

				<section>
					<div style="display: flex; flex-direction: row; align-items: flex-end;">
						<div style="flex: 1 1 300px">
							<img src="./assets/qrcode_davefancher.github.io.png">
						</div>
						<div style="flex: 1 1 300px; text-align: left; padding-left: 20px;">
							<h2>Thank You!</h2>

							<p style="font-size: 0.5em">
								Dave Fancher<br />
								Lead Software Engineer - Vibenomics
							</p>
							<hr />
							<p style="font-size: 0.5em">
								Twitter: @davefancher<br />
								LinkedIn: davefancher
							</p>
						</div>
					</div>
				</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
